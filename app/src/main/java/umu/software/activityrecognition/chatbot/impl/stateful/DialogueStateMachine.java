package umu.software.activityrecognition.chatbot.impl.stateful;


import android.util.Pair;

import com.github.oxo42.stateless4j.StateMachine;
import com.github.oxo42.stateless4j.StateMachineConfig;
import com.github.oxo42.stateless4j.triggers.TriggerWithParameters1;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java.util.Collection;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import umu.software.activityrecognition.chatbot.ChatbotResponse;
import umu.software.activityrecognition.shared.util.LogHelper;


/**
 * Finite State Machine to handle dialogues
 */
public class DialogueStateMachine
{
    public enum Trigger
    {
        EVENT, MESSAGE, RESET, RESTART;
    }


    private ChatbotResponse currentResponse = new ChatbotResponse();
    private final Integer s0 = 0;
    private final StateMachineConfig<Integer, Trigger> config = new StateMachineConfig<>();
    private final StateMachine<Integer, Trigger> stateMachine = new StateMachine<>(s0, config);

    private final Map<Integer, Collection<Pair<Integer, IDialogueTransition>>> states = Maps.newHashMap();

    private Map<String, String> properties = Maps.newHashMap();

    private final Map<Integer, Integer> errorStates = Maps.newHashMap();
    private final Map<Integer, Integer> resetStates = Maps.newHashMap();

    private boolean initialized = false;

    private final LogHelper log = LogHelper.newClassTag(this);


    /**
     * Sets the dialogue global properties
     * @param properties
     */
    public void setProperties(Map<String, String> properties)
    {
        this.properties = Maps.newHashMap(properties);
    }

    /**
     * Retrieves and cast a global property
     * @param key key of the property
     * @param defaultValue default value to return if the property is not found
     * @param castFunction function to cast the property (string) to a data type
     * @param <T> type of the casted property
     * @return
     */
    public <T> T getProperty(String key, T defaultValue, Function<String, T> castFunction)
    {
        if (!properties.containsKey(key)) return defaultValue;
        return castFunction.apply(properties.get(key));
    }

    /**
     * Resets the FSM to its initial state
     */
    public void resetToInitialState()
    {
        initializeIfNeeded();
        stateMachine.fire(Trigger.RESTART);
        currentResponse = new ChatbotResponse();
    }


    /**
     * Handle an event through a FSM
     * @param eventName input event sent by the user
     * @return the response generated by the FSM
     */
    public ChatbotResponse onEvent(String eventName)
    {
        //log.d("Received event (%)", eventName.toString());
        initializeIfNeeded();
        stateMachine.fire(new TriggerWithParameters1<>(Trigger.EVENT, String.class), eventName);
        return currentResponse;
    }


    /**
     * Handle a message through a FSM
     * @param message input user message
     * @return the response generated by the FSM
     */
    public ChatbotResponse onMessage(String message)
    {
        //log.d("Received message (%)", message);
        initializeIfNeeded();
        stateMachine.fire(new TriggerWithParameters1<>(Trigger.MESSAGE, String.class), message);
        return currentResponse;
    }


    /**
     * Brings the dialogue to the 'reset' state.
     * Should be called after ~30 seconds of inactivity
     * @return the response generated by the FSM
     */
    public ChatbotResponse onReset()
    {
        initializeIfNeeded();

        int currState = stateMachine.getState();
        int destState = resetStates.getOrDefault(currState, currState);

        log.d("Received RESET. Transitioning to state (%s)", destState);
        stateMachine.fire(new TriggerWithParameters1<>(Trigger.RESET, Integer.class), destState);
        return currentResponse;
    }


    /**
     * Sets the reset state for 'src', that is where the FSM is brought after a reset transition (through onReset()).
     * States for which the reset state is unspecified will not transition
     * @param src source state
     * @param dest destination state in case of reset
     */
    public void setResetState(int src, int dest)
    {
        resetStates.put(src, dest);
    }

    /**
     * Sets the error state for 'src', that is where the FSM is brought if an input doesn't find any
     * valid transition. States for which the error state is unspecified will not transition
     * @param src source state
     * @param dest destination state in case of error
     */
    public void setErrorState(int src, int dest)
    {
        errorStates.put(src, dest);
    }

    /**
     * Add a transition between states.
     * If multiple states can be transitioned at any given time only the first one is fired
     * @param src source state
     * @param dest destination state
     */
    public void setTransition(int src, int dest, IDialogueTransition transition)
    {
        if (initialized) throw new RuntimeException("FSM is already initialized");
        registerState(src);
        registerState(dest);

        Pair<Integer, IDialogueTransition> t = Pair.create(dest, transition);

        if (states.get(src).contains(t)) return;

        states.get(src).add(t);
    }

    public int getInitialState()
    {
        return s0;
    }


    /**
     * Initialize the finite state machine.
     * Called only one time at the first call
     */
    public void initializeIfNeeded()
    {
        if (initialized) return;
        initialized = true;

        config.configure(s0).ignore(Trigger.RESTART);
        for (Integer src : states.keySet())
        {
            config.configure(src)
                    .permitDynamic(
                            new TriggerWithParameters1<>(Trigger.EVENT, String.class),
                            (arg) -> findNextState(
                                    src,
                                    arg,
                                    tr -> tr.testEvent(arg, properties)
                            ),
                            (arg) -> makeResponse(
                                    src,
                                    arg,
                                    tr -> tr.testEvent(arg, properties),
                                    tr -> tr.onEvent(arg, currentResponse, properties)
                            )
                    )
                    .permitDynamic(
                            new TriggerWithParameters1<>(Trigger.MESSAGE, String.class),
                            (arg) -> findNextState(
                                    src,
                                    arg,
                                    tr -> tr.testMessage(arg, properties)
                            ),
                            (arg) -> makeResponse(
                                    src,
                                    arg,
                                    tr -> tr.testMessage(arg, properties),
                                    tr -> tr.onMessage(arg, currentResponse, properties)
                            )
                    )
                    .permitDynamic(
                            new TriggerWithParameters1<>(Trigger.RESET, Integer.class),
                            (destState) -> destState
                    );
        }


    }

    /**
     * Register a FSM state
     * @param state state tp register
     */
    private void registerState(int state)
    {
        if (!states.containsKey(state))
        {
            states.put(state, Lists.newArrayList());
            if (state != s0)
                config.configure(state).permit(Trigger.RESTART, s0);
        }
    }

    /**
     *
     * @param src source state
     * @param arg transition argument. Either an event or message
     * @param testState function to find the right transition to activate. The first state testing positive is selected
     * @return
     */
    private Integer findNextState(int src, String arg, Function<IDialogueTransition, Boolean> testState)
    {
        int destState;
        for (Pair<Integer, IDialogueTransition> dest : states.get(src))
            if (testState.apply(dest.second))
            {
                destState = dest.first;
                log.d("Dialogue state change (%s) -> (%s)", src, destState);
                return destState;
            }
        destState = errorStates.getOrDefault(src, src);
        log.d("Unrecognized input (%s), performing error transition: (%s) -> (%s)", arg, src, destState);
        return destState;
    }

    /**
     * Makes a response through the right transition
     * @param src source state
     * @param arg transition argument. Either an event or message
     * @param testState function to find the right transition to activate. The first state testing positive is selected
     * @param responseBuilder response builder
     */
    private void makeResponse(int src, String arg, Function<IDialogueTransition, Boolean> testState, Consumer<IDialogueTransition> responseBuilder)
    {
        int nextState = findNextState(src, arg, testState);
        for (Pair<Integer, IDialogueTransition> dest : states.get(src))
            if (testState.apply(dest.second))
            {
                assert nextState == dest.first;
                if (dest.second.resetResponse())
                    currentResponse = new ChatbotResponse();
                responseBuilder.accept(dest.second);
                return;
            }
        currentResponse = ChatbotResponse.forError(String.format("FSM error: missing transition from state (%s) for input (%s)", src, arg));
    }
}
